<!-- <<{ comments -->

{{! will not output to html  }}
{{!-- will not ouput to html, can contain {,} --}}
<!-- will output to html -->

<!-- }>> -->

<!-- <<{ built-in helpers -->

{{! if helper }}
{{#if some}}
  ...
{{else if some2}}
  ...
{{else}}
  ...
{{/if}}


{{! content will render if some is falsy }}
{{#unless some}}
  ...
{{/unless}}

{{! looping through array/object }}
{{#each list}}
  {{@root}} - intial context with which template was executed
  {{@first}} - true if it is the first item in #each 
  {{@last}} - true if it is the last item in #each
  {{@index}} - zero-based index for the current iteration in #each
  {{@key}} - key name for the current object iteration in #each
{{else}}
  will render if list is empty
{{/each}}

{{! provide context some to the inner template }}
{{#with some}}
  ...
{{else}}
  will render if some is empty
{{/with}}

{{! provide aliases with context }}
{{#with some.number as | x |}}
  {{x}}
{{/with}}

{{lookup obj prop}} - dynamically resolve prop from obj/array

<!-- }>> -->

<!-- <<{ compiling templates -->

const t = Handlebars.compile('<p>{{x}}</p>') - compiling template
t({ x: 25 }) - creating compiled html string from template


const pre = Handlebars.precompile('<p>{{x}}</p>') - precompiling template, so it can be sent over net
const t = Handlebars.template(pre) - sets up precompiled template
t({ x: 25 })

<!-- }>> -->

<!-- <<{ custom helpers -->

- creating inline helper

Handlebars.registerHelper('loud', function (context) {
    return context.toUpperCase()
})


- mark return value as safe, so handlebars will not try to escape it even in {{{...}}}

Handlebars.registerHelper("bold", function(text) {
  var result = "<b>" + Handlebars.escapeExpression(text) + "</b>";
  return new Handlebars.SafeString(result);
});


- creating block helper

Handlebars.registerHelper("bold", function(context, options) {
  return new Handlebars.SafeString('<div class="mybold">' + options.fn(this) + "</div>");
});

- creating conditional block helper

Handlebars.registerHelper("if", function(conditional, options) {
  if (conditional) {
    return options.fn(this);
  }
});

Handlebars.unregisterHelper('name') - unregister helper


{{#bold}}{{some}}{{/bold}} - using block helper
{{#if some}}...{{else}}...{{/if}} - using conditional block helper
{{#if some}}...{{else if some2}}...{{else}}...{{/if}} - using chained conditional block helper
{{{{bold}}}}...{{{{/bold}}}} - do not escape content inside block helper

options.fn(this) - creating compiled html string from template betweeb helper tags, this - current context
options.inverse(this) - creating compiled html string from template after {{else}} tag
options.hash - object with provided params to helper

{{helper}} - inline helper with no params
{{helper url=data.url name="John"}} - inline helper with params
{{helper1 (helper2 x=24) name="Sam"}} - helper param as a result of another helper


<!-- }>> -->

<!-- <<{ expression -->

{{some}} - escaped expression - &amp, &lt, &gt, &quot, &#x27, &#x60, &#x3D
{{{some}}} - not escaped expression - &, <, >, ", ', `, =
{{obj.some}} - obj property
{{obj.[some-prop]}} - obj property with some not allowed chars
{{array.[0]}} - array element

{{~#if test}} - omit all the whitespaces to the left
{{~/if~}} - omit all the whitespaces on both sides

\{{some}} - inline escaping of handlebars chars

<!-- }>> -->

<!-- <<{ partials -->

Handlebars.registerPartial('name', '<p>{{some}}</p>') - register partial
Handlebars.unregisterPartial('name') - unregister partial

{{> partial }} - partial
{{> partial context }} - partial with provided context
{{> partial x=23 }} - partial with parameters
{{> (partial) }} - dynamically get partial name via partial function
{{> (lookup . 'varName') }} - dynamically get partial name via variable

- passing content to partial

{{#> partial }}
  some content
{{/partial}}

{{> @partial-block }} - placeholder for content in partial

<!-- }>> -->

