- creating inline helper

Handlebars.registerHelper('loud', function (context) {
    return context.toUpperCase()
})


- mark return value as safe, so handlebars will not try to escape it even in {{{...}}}

Handlebars.registerHelper("bold", function(text) {
  var result = "<b>" + Handlebars.escapeExpression(text) + "</b>";
  return new Handlebars.SafeString(result);
});


- creating block helper

Handlebars.registerHelper("bold", function(context, options) {
  return new Handlebars.SafeString('<div class="mybold">' + options.fn(this) + "</div>");
});

- creating conditional block helper

Handlebars.registerHelper("if", function(conditional, options) {
  if (conditional) {
    return options.fn(this);
  }
});

Handlebars.unregisterHelper('name') - unregister helper


{{#bold}}{{some}}{{/bold}} - using block helper
{{#if some}}...{{else}}...{{/if}} - using conditional block helper
{{#if some}}...{{else if some2}}...{{else}}...{{/if}} - using chained conditional block helper
{{{{bold}}}}...{{{{/bold}}}} - do not escape content inside block helper

options.fn(this) - creating compiled html string from template betweeb helper tags, this - current context
options.inverse(this) - creating compiled html string from template after {{else}} tag
options.hash - object with provided params to helper

{{helper}} - inline helper with no params
{{helper url=data.url name="John"}} - inline helper with params
{{helper1 (helper2 x=24) name="Sam"}} - helper param as a result of another helper

